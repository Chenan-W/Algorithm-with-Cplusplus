#### 31 整数中1出现的次数（从1到n整数中1出现的次数）（Easy，数学）
> 此题目为计算从1到n中已出现的次数，如计算1，2，3，4，5，6，7，8，9，10，11中1出现的次数，结果为出现4次。  
非常简单，略。

#### 32 把数组排成最小的数（Medium，数组，排序）
> 此题目为给定一个正整数数组，输出所有可拼接成的数字中最小的那一个。   
解决此题需要构建一个排序标准，见代码。

#### 33 丑数（Medium，穷举）
> 此题目为寻找第N个丑数，所谓丑数，就是只包含质因子2，3，5的数，即丑数可以被表示成几个2和几个3和几个5相乘的形式。  
在穷举过程中会发现规律，1，2，3，4，5，6，8，9，10，11，13，，，第一个数为{1}，第二个数是1×2，1×3，1×5中最小的那个数{1，2}，第三个数是剩余数1×3，1×5，和新出现的2×2，2×3，2×5中最小的那个数{1，2，3}，第四个数是剩余数1×5，2×2，2×3，2×5，和新出现的3×2，3×3，3×5中最小的那个数{1，2，3，4}，我们发现在得到第二个丑数时比较了1×2，1×3，1×5，得到第三个丑数时比较了2×2，1×3，1×5，得到第四个丑数时比较了3×2，2×3，1×5，以此类推。详解见：https://segmentfault.com/a/1190000015753301 。

#### 34 第一个只出现一次的字符（Easy，字符串）
> 此题目为找出给定字符串中只出现一次的字符的位置，没有则扣-1。  
遍历一遍字符串，map记录每个字符的次数，再次遍历字符串，找出那个出现次数为1的字符后返回其位置。

#### 35 数组中的逆序对（Medium，归并排序）
> 此题目为计算给定数组中的逆序对对数。  
此题考察了归并排序的思想，向下拆分至二元，排序，计数，再向上合并，最终得到逆序对总数。见代码。

#### 36 两个链表的第一个公共结点（Easy，链表）
> 此题目为寻找两个链表的第一个公共节点。   
有两个链表：`1->2->3->4->5->6->null`和`2->4->5->6->null`，它们的第一个公共节点是4，最直观的方法是：首先我们遍历两个链表计算其各自的长度，然后先让较长的先走完差值个节点，然后同时遍历两个链表直至遇到相同的那个节点。可实际上我们没必要知道这个差值，仅需要遍历两次链表即可，见代码。

#### 37 数字在排序数组中出现的次数（Easy，数组）
> 此题目为计算某个数字在一个排序数组中出现的次数。  
简单，因为是排序数组，注意遍历的终止条件。

#### 38 二叉树的深度（Medium，树，递归）
> 此题目为计算一棵二叉树的深度。  
使用递归解决，每次返回左右子树中最深的深度。   

#### 39 平衡二叉树（Medium，树，递归）
> 此题目为判断一棵二叉树是否为一棵平衡二叉树，所谓平衡二叉树，即二叉树的高度差不能超过1。  
这道题有点类似上一题求二叉树的深度，需要稍微做些改动，即在求二叉数深度的过程中加入是否平衡的判断即可。见代码。

#### 40 数组中只出现一次的数字（Easy，数组）
> 此题目为找出一个数组中唯二只出现一次的两个数字，其余数字均出现两次。  
最简单的思路仍然是，map计数，但是这种方法会利用到额外空间，最优解的空间复杂度是O(1)的，见代码。
 
