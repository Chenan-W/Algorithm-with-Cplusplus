#### 21 栈的压入弹出序列（Medium，栈，过程模拟）
> 此题目为给定两个整数序列，一个代表栈的压入序列，判断另一个序列是否为该栈的弹出序列。  
有两种方法AC这道题，一种是保证弹出序列中的数字要保持其在压入序列中的相对位置不变，举个例子，如压入序列为{1，2，3，4，5}， 则{4，5，3，2，1}是其对应的一个弹出序列，其中3，2，1的相对位置没有发生变化，因为4被首先弹出，说明3，2，1已被压入栈，而弹出的顺序3一定比2先弹出来，而2一定比1先弹出来，4后面的数字可以在4后的任一位置弹出，不过该方法实现起来较为复杂；另一种方法是简单的利用一个栈按照给定的弹出序列模拟一遍压入弹出过程，若不与压入序列产生冲突则说明是，见代码。

#### 22 从上往下打印二叉树（Medium，树，队列，广度优先搜索（BFS），层序遍历）
> 此题目为从左到右层序遍历一棵二叉树的每个节点，即广度优先搜索。   
通常我们使用队列（queue）来实现BFS，将每层节点压入一个队列中，然后记录下队列首元素的值，并从队首弹出，压入其左右子树，直至队列为空。见代码。

#### 23 二叉搜索树的后序遍历序列（Medium，树，递归）
> 此题目为判断一个整数数组是否是一棵二叉搜索树的后序遍历序列，无重复数字。  
二叉搜索树的特点是节点左孩子的值<节点值<节点右孩子的值，其中序遍历为一个递增序列。后序遍历的特点是序列的最后一个元素为根节点，比该元素大的为其左子树的后序遍历序列，比该元素小的为其右子树的后序遍历序列，若其子序列中有元素值与该规则产生冲突则该序列不是一棵二叉搜索树的后序遍历序列。

#### 24 二叉树中和为某一值的路径（Hard，树，递归，回溯）
> 此题目为将二叉树中和为某一目标值的从根节点到叶节点的全部路径储存起来。  
我们采用递归的方法，终止条件为判断到叶子节点，若这一路径的和为目标值，则将这一路径储存起来，并在回溯过程将当前节点弹出。见代码。

#### 25 复杂链表的复制（Hard，链表）
> 此题目为给定一个复杂链表，该复杂链表复杂在每个节点不单含有next指向下一个节点，它还包含一个random节点随机的指向任意一个节点，我们的任务是将其复制一份新的链表并返回新链表表头。  
该问题乍一看似乎很简单，就是生成一个一模一样的链表填值就可以了，不过仔细想下去，这样做无法处理random节点问题。该题的解法分为三步，第一步复制，遍历该链表的同时在每个节点的后面复制一份该节点，即由1->2->3->NULL变换为1->1->2->2->3->3->NULL；第二步赋值，给复制的每个节点的random指向的节点赋值；第三步拆分，将复制的全部节点从原链表中差分出来，得到新的一份一模一样的链表。见代码。

#### 26 二叉搜索树与双向链表（Medium，链表，树，递归）
> 此题目为将一棵给定的二叉搜索树转换为一个有序的双向链表。  
我们知道二叉搜索树的中序遍历是个有序数列，我们以此为出发点，中序遍历构建双向链表。见代码。

#### 27 字符串的排列（Hard，字符串，递归，回溯，动态规划）
> 此题目为按字典顺序打印出给定字符串中字符的全排列。  
这道题还挺难的，网上看了视频题解才仿照做了出来，即使我第二遍再看此问题还是懵的。OK，大概讲一下，总体来说是显得到所有排列的结果之后再排序输出。在得到所有排列结果的过程中，一个思想就是字符串中的每个字符在每个位置都出现了一遍，emmm，见代码。

#### 28 数组中出现次数超过一半的数字（Easy，数组）
> 此题目为找出一个数组中出现次数超过数组长度一半的那个元素，没有则扣0。   
使用Boyer-Moore多数投票算法，时间复杂度为`O(n)`，空间复杂度为`O(1)`。

#### 29 最小的K个数（Medium，数组，红黑树，最大堆）
> 此题目为给定n个整数，找出其中最小的K个整数。   
该题考察了红黑树，最大堆的数据结构问题。利用其插入（insert），删除（erase）操作的时间复杂度为O(logn)及最大堆的性质来AC这道题。  

#### 30 连续子数组的最大和（Medium，数组）
> 此题目为计算一个包含正负整数的数组中的连续字串的最大和。   
最核心的思想就是：只要当前连续字串和大于0，就可以继续延长该字串，否则重新开始一个新的字串，并记录这一过程中出现的所有连续字串和的最大值。见代码。

