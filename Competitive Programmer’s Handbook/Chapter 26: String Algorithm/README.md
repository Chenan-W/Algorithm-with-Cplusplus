# String Algorithm
We assume that zero-based indexing is used in strings. Strings are compared using the **lexicographical order**. A fundamental string processing problem is the **pattern matching** problem.

## String Terminology   
* **Substring**: a sequence of consecutive characters in a string.
* **Subsequence**: is a sequence of (not necessarily consecutive) characters in a string in their original order.
* **Prefix(Suffix)**: a substring that starts at the beginning(ends at the end) of a string.
* **Rotation**: can be generated by moving the characters of a string one by one from the beginning to the end (or vice versa).
* **Period**: a prefix of a string such that the string can be constructed by repeating the period.
* **Border**: a string that is both a prefix and a suffix of a string.

## Trie structure
Using a trie, we can find the **longest prefix** of a given string such that the prefix belongs to the set. Moreover, by storing additional information in each
node, we can calculate the number of strings that belong to the set and have a given string as a prefix.

## String Hashing
String hashing is a technique that allows us to efficiently check whether two strings are equal.
### Calculating hash values
A usual way to implement string hashing is **polynomial hashing**, which means that the hash value of a string `s` of length `n` is
$$
(s[0] A^{n − 1} + s[1] A^(n − 2) + · · · + s[n − 1] A^0) mod B
$$
where `s[0], s[1], . . . , s[n − 1]` are interpreted as the codes of the characters of `s` , and `A` and `B` are pre-chosen constants.

### Preprocessing
Using polynomial hashing, we can calculate the hash value of any substring of a string s in `O(1)` time after an `O(n)` time preprocessing.
```c++
string s = "ABCDEABC";
int n = s.length();
int h[n];  // h[k] contains the hash value of the prefix s[0...k]
h[0] = s[0];
for(int i = 1; i < n; ++i) {
    h[i] = (h[i-1] * A + s[i]) % B;
} 
int p[n];  // p[k] = A^k mod B
p[n-1] = 1;
for(int i = n-2; i >= 0; --i) {
    p[i] = (p[i+1] * A) % B;
}
// p: [1, A, A^2, ... A^{n-1}]
```
After this, the hash value of any substring `s[a . . . b]` can be calculated in `O(1)` time using the formula:    
```c++
(h[b] - h[a-1] * p[a-1]) % B;
```




## Reference
1. [[Tutorial] Rolling hash and 8 interesting problems [Editorial]](https://codeforces.com/blog/entry/60445)
