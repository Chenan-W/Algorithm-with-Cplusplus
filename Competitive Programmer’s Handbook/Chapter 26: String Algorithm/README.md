# String Algorithm
We assume that zero-based indexing is used in strings. Strings are compared using the **lexicographical order**. A fundamental string processing problem is the **pattern matching** problem.

## String Terminology   
* **Substring**: a sequence of consecutive characters in a string.
* **Subsequence**: is a sequence of (not necessarily consecutive) characters in a string in their original order.
* **Prefix(Suffix)**: a substring that starts at the beginning(ends at the end) of a string.
* **Rotation**: can be generated by moving the characters of a string one by one from the beginning to the end (or vice versa).
* **Period**: a prefix of a string such that the string can be constructed by repeating the period.
* **Border**: a string that is both a prefix and a suffix of a string.

## Trie Structure
Using a trie, we can find the **longest prefix** of a given string such that the prefix belongs to the set. Moreover, by storing additional information in each
node, we can calculate the number of strings that belong to the set and have a given string as a prefix.

## String Hashing
String hashing is a technique that allows us to efficiently check whether two strings are equal.
### Calculating Hash Values
A usual way to implement string hashing is **polynomial hashing**, which means that the hash value of a string `s` of length `n` is
$$ (s[0] A^{n − 1} + s[1] A^(n − 2) + · · · + s[n − 1] A^0) mod B $$
where `s[0], s[1], . . . , s[n − 1]` are interpreted as the codes of the characters of `s` , and `A` and `B` are pre-chosen constants.

### Preprocessing
Using polynomial hashing, we can calculate the hash value of any substring of a string s in `O(1)` time after an `O(n)` time preprocessing.
```c++
string s = "ABCDEABCCCCABCDE", t = "ABC";
int A = 911382323, B = 972663749;
int n = s.length(), m = t.length();
int h[n + 1];  // h[k] contains the hash value of the prefix s[0...k], i.e. [0, k)
h[0] = 0;
for(int i = 0; i < n; ++i) {
    h[i + 1] = (1LL * h[i] * A + s[i]) % B;
} 
int need = t[0];
for(int i = 1; i < m; ++i) {
    need = (1LL * need * A + t[i]) % B;
} 
int p[n];  // p[k] = A^k mod B
p[0] = 1;
for(int i = 1; i < n; ++i) {
    p[i] = (1LL * p[i-1] * A) % B;
}
// p: [1, A, A^2, ... A^{n-1}]

for(int i = 0; i <= n - m; ++i) {
    if((h[i + m] - 1LL * h[i] * p[m] % B + B) % B == need)
        cout << i << " ";
}
```
After this, the hash value of any substring `s[a ... b]` can be calculated in `O(1)` time using the formula:    
```c++
(h[b] - h[a-1] * p[b-a+1]) % B;
```

### Collisions and Parameters
An evident risk when comparing hash values is a **collision**, which means that two strings have different contents but equal hash values. Collisions are always possible, because the number of different strings is larger than the number of different hash values. We can choose A and B carefully: tochoose random constants near `10^9` , for example as follows: `A = 911382323, B = 972663749`, and then use a `long long` type to contain to hash value. Also, we can make the probability of a collision smaller by calculating **multiple hash values** using different parameters.

## Z-Algorithm
The **Z-array** `z` of a string `s` of length `n` contains for each `k = 0, 1, ... , n − 1` the length of the longest substring of `s` that begins at position `k` and is a prefix of `s`. Thus, `z[k] = p` tells us that `s[0 ... p−1]` equals `s[k ... k+p−1]`.

### Algorithm Description
**Z-algorithm**, that efficiently constructs the Z-array in `O(n)` time. At each position `k`, we first check the value of `z[k − x]`. If `k + z[k − x] < y`, we
know that `z[k] = z[k − x]`. However, if `k + z[k − x] ≥ y`, `s[0 ... y − k]` equals `s[k ... y]`, and to determine the value of `z[k]` we need to compare the substrings character by character.
```c++
vector<int> zAlgorithm(string s) {
    int n = s.length();
    vector<int> z(n);
    int x = 0, y = 0;
    for(int k = 1; k < n; ++k) {
        z[k] = max(0, min(z[k-x], y-k+1));  // 0 -- i-x -- x -- i -- y
        while(k + z[k] < n && s[z[k]] == s[k + z[k]]) {
            x = k; y = k + z[k]; ++z[k];
        }
    }
    return z;
}
/*
input: ACBACDACBACBACDA
output: 0 0 0 2 0 0 5 0 0 7 0 0 2 0 0 1  
*/
```
### Using the Z-array to solve the "pattern matching problem"
For example, if `s = HATTIVATTI` and `p = ATT`, we first construct a new string `p#s` that `ATT#HATTIVATTI`, then we use the Z-algorithm to get the Z-array of this new string.

## Combine String Hashing with Binary Search
```c++
/* 
Source Code: https://ideone.com/8fDG3W 
*/
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

// Generate random base in (before, after) open interval:
int gen_base(const int before, const int after) {
    auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
    mt19937 mt_rand(seed);
    int base = uniform_int_distribution<int>(before + 1, after)(mt_rand);
    return base % 2 == 0 ? base - 1 : base;  // odd number
}

struct PolyHash {
    static const int mod = (int)1e9 + 123;  // prime mod of polynomial hashing
    static vector<int> pow1;
    static vector<ull> pow2;
    static int base;

    vector<int> perf1;
    vector<ull> perf2;

    PolyHash(const string& s) : perf1(s.length() + 1u, 0) , perf2(s.length() + 1u, 0) {
        assert(base < mod);
        const int n = s.length();
        while((int)pow1.size() <= n) {
            pow1.push_back(1LL * pow1.back() * base % mod);
            pow2.push_back(pow2.back() * base);  // always smaller than 2^64-1
        }
        for(int i = 0; i < n; ++i) {
            perf1[i+1] = (1LL * perf1[i] * base + s[i]) % mod;
            perf2[i+1] = perf2[i] * base + s[i];
        }
    }

    inline pair<int, ull> operator()(const int pos, const int len) {
        int hash1 = (perf1[pos + len] - 1LL * perf1[pos] * pow1[len] % mod + mod) % mod;
        ull hash2 = perf2[pos + len] - perf2[pos] * pow2[len];
        return make_pair(hash1, hash2);
    }
};

int PolyHash::base((int)1e9+7);
vector<int> PolyHash::pow1{1};
vector<ull> PolyHash::pow2{1};
```
1. Searching all occurrences of one string of length `n` in another string length `m` in `O(n + m)` time.
2. Searching for the largest common substring of two strings of lengths `n` and `m` (`n ≥ m`) in `O((n + m·log(n))·log(m))` and `O(n·log(m))` time.
3. Finding the lexicographically minimal cyclic shift of a string of length `n` in `O(n·log(n))` time.
4. Sorting of all cyclic shifts of a string of length `n` in lexicographic order in `O(n·log(n)^2)` time.
5. Finding the number of sub-palindromes of a string of length `n` in `O(n·log(n))` time.
6. The number of substrings of string of length `n` that are cyclic shifts of the another string length `m` in `O((n + m)·log(n))` time.
7. The number of suffixes of a string of length `n`, the infinite extension of which coincides with the infinite extension of the given string for `O(n·log(n))` (extension is a duplicate string an infinite number of times).
8. Largest common prefix of two strings length `n` with swapping two chars in one of them `O(n·log(n))`.

## Reference
1. [[Tutorial] Rolling hash and 8 interesting problems [Editorial]](https://codeforces.com/blog/entry/60445)
2. [On the mathematics behind rolling hashes and anti-hash tests](https://codeforces.com/blog/entry/60442)


